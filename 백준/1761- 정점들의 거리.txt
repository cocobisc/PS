#include <bits/stdc++.h>
using namespace std;
const int MAX = 4e4 + 1, MAH = 17;
int parent[MAX][MAH], dist[MAX], level[MAX]; // root - node distance
vector<pair<int,int>> adj[MAX];


void makeTreeByDFS(int curr) {
	for (auto next : adj[curr]) {
		if (level[next.first] == -1) {
			parent[next.first][0] = curr;
			level[next.first] = level[curr] + 1;
			dist[next.first] = dist[curr] + next.second;
			makeTreeByDFS(next.first);
		}
	}
}
int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	int n; cin >> n;
	for (int i = 0; i < n - 1; i++) {
		int u, v, w; cin >> u >> v >> w;
		adj[u].push_back({ v,w });
		adj[v].push_back({ u,w });
	}
	memset(parent, -1, sizeof(parent));
	memset(level, -1, sizeof(level));
	level[1] = 0;
	makeTreeByDFS(1);

	for (int k = 1; k < MAH; k++) 
		for (int i = 1; i <= n; i++) 
			if (parent[i][k - 1] != -1) 
				parent[i][k] = parent[parent[i][k - 1]][k - 1];

	// u - LCA - v 의 거리
	// => (u - LCA) 의 거리 + (LCA + v) 의 거리
	// =>  (root - u) 의 거리 - (root - LCA) 의 거리 + 
	//         (root - v) 의 거리 - (root - LCA) 의 거리
	// => (root - u) + (root - v) - 2 * (root - LCA)

	int m; cin >> m;
	for (int i = 0; i < m; i++) {
		int ans;
		int u, v; cin >> u >> v;

		ans = dist[u] + dist[v];
		if (level[u] < level[v]) swap(u, v);
		
		int diff = level[u] - level[v];
		for (int j = 0; diff; j++) {
			if (diff % 2) u = parent[u][j];
			diff /= 2;
		}

		if (u != v) {
			for (int j = MAH - 1; j >= 0; j--) {
				if (parent[u][j] != -1 && parent[u][j] != parent[v][j]) {
					u = parent[u][j];
					v = parent[v][j];
				}
			}
			u = parent[u][0];
		}
		cout << ans - 2 * dist[u] << '\n';
	}
}